+++
title = "パスワードの生成と保持"
description = ""
weight = 70
+++


この節ではパスワードの生成と保持について述べる．
ここに説明するようなことをよく理解しなくても，動作しているコードを
適当にコピー・ペーストすれば，なんとなく動くサイトができてしまうが，
危険である．できるかぎり理解するように試みることを勧める．

## 文字列とバイト列

パスワードの取扱に関して本質的な話ではないのだが，
準備として文字列とバイト列について述べる．
プログラミングをしていく上で，いろいろな場面で文字列とバイト列が
出てくることがあるので，この機会に理解をすすめてほしい．

### バイト

___ビット___ (bit) というのは，0 または 1 を保持できる記憶単位であった．
ビットが8つ並んだものを，___バイト___ (byte) と称するのであった．
1つのバイトには，`00000000` から `11111111` までの，$2^8 = 256$
種類の情報のいずれかを記録することができる．

バイトの値を8つの 0 や 1 で表記する (2進表記) のはとても見づらいので，
前半4ビットと後半4ビットに分けて，
0から9までの数字と，aからfまでのアルファベットを
用いて，次のように表記する．16進表記と呼ばれる．
アルファベットa-fは大文字A-Fを用いることもある．

| 2進表記 | 16進表記 | 2進表記 | 16進表記 | 2進表記 | 16進表記 | 2進表記 | 16進表記 |
|---|---|---|---|---|---|---|---|
| 0000 | 0 | 0001 | 1 | 0010 | 2 | 0011 | 3 |
| 0100 | 4 | 0101 | 5 | 0110 | 6 | 0111 | 7 |
| 1000 | 8 | 1001 | 9 | 1010 | a | 1011 | b |
| 1100 | c | 1101 | d | 1110 | e | 1111 | f |

たとえば2進表記のバイト `11100101` は，16進表記では e5 となる．

### バイト列

Python では，バイトの並びを保持する型を___バイト列___ (byte sequence) と呼ぶ．
バイト列のリテラルは，次のように表される

* 全体を単一引用符または二重引用符で囲い，直前に文字 `b` を置く．
* 各バイトは，バックスラッシュ - x に引き続いて，16進で表記する．

たとえば，`11100101` と `00000000` が並んでいるバイト列は，
`b'\xe5\x00'` と表記される．

```python
print(b'\xe5\x00')
```

### 文字列のバイト列表現

文字列は，それに対応するバイト列の表現を持つ．ただし，一筋縄ではいかない．
まず，[ASCII 文字](https://www.techonthenet.com/ascii/chart.php) 
は，00 から 7E までのバイトに対応している．
(00から7Eまでのすべてのバイトが対応する文字を持つわけではない)
たとえば，Aに対応するバイトは 41 であり，Z に対応するバイトは 5a である．
そこで，文字列 `'AZ'` には，バイト列 `b'\x41\x5a'` が対応する．

この対応関係を，Python では，文字列のメソッド encode() と，
バイト列のメソッド decode() で実装している．

```python
b'\x41\x5a'.decode()   # 'AZ'
```

```python
'AZ'.encode()          # b'\x41\x5a' なのだが，b'AZ' と表示される．
```

`'AZ'.encode()` の実行結果は，バイト列 `b'\x41\x5a'` なのであるが，
このバイト列を `b'AZ'` とも表記する．
つまり，ASCII 文字 c に対応するバイトが dd であるとき，
`b'\xdd'` のことを，`b'c'` とも書くのである．

ここで，文字列 `'AZ'` は，バイト列 b'\x41\x5a' とは，
あくまで対応しているだけであることに注意されたい．
文字列 'AZ' が，Python の内部でバイト列 b'\x41\x5a' という
___表現を持っているわけではない___．

```python
b'AZ' == 'AZ'           # False
```

### ASCII以外の文字

それでも，ASCII 文字については，
対応するバイト列が1つに決まっている (しかも，長さは1である) 
のでまだ良いのであるが，
一般にはこの対応関係は一つには決まらない．
たとえば `'あ'` という文字に対応するバイト列は，いろいろな
可能性がある．ここでさらに ___エンコーディング___ (encoding) なるものを
決めて，はじめて，対応するバイト列が定まることになる．

日本では，実用上よく用いられるエンコーディングが (残念ながら) 2つある．
一つは utf-8，もうひとつが cp932 である．
cp932 は，いわゆる Shift JIS の符号化方式をベースにして，
文字集合を拡張したものになっている．

Python のメソッド encode と decode は，
名前付き引数 encoding に，エンコーディングを指定できるようになっている．
省略すると，'utf-8' である．

```python
print('あ'.encode(encoding='utf-8'))      # b'\xe3\x81\x82'
print('あ'.encode(encoding='cp932'))      # b'\x82\xa0'
print('あ'.encode())                     # b'\xe3\x81\x82'

print(b'\xe3\x81\x82'.decode(encoding='utf-8'))    # 'あ'
print(b'\x82\xa0'.decode(encoding='cp932'))        # 'あ'
print(b'\x82\xa0'.decode(encoding='utf-8'))        # エラー
```

この最後の例は，たまたまエラー (UnicodeDecodeError) になってくれた．
しかし，残念ながら，いつでもエラーになってくれるとは限らず，
全く関係無い文字になってしまうこともある．

### base64

上の話とは全く違う文脈で使われる (しかし，文字列とバイト列に関連する)
概念として，base64 というものがある．
これは，任意のバイト列をASCII文字列で表現するというものである．

コンピュータ上で扱われるデータは，文字列の他にもたくさんある．
画像，動画，音声，...．これらのデータは (いろいろ留保はあるものの)
バイト列で表すことができる．これを文字列に変換したいことがある．
たとえばメールでデータを送りたいとすると，メールには文字列しか
書くことができない (もともとはASCII文字しか書けなかったのである) ので，
なんとか文字にして送って，受取先でまたバイト列に戻してもらおう，という
アイディアが考えられた．

データベースも，もともとは，文字と数値しか格納できなかった．
今では，任意のバイト列を格納することができるが，いろいろ注意を払わなければ
ならない点がある．文字列にして格納してしまい，取り出した後に
バイト列に戻した方が面倒が少ない (場合もある)．

Python では，base64 ライブラリのメソッド b64encode と b64decode
によって，base64エンコーディングとデコーディングが実現されている．
b64encode() によって，任意のバイト列をASCII文字列に
変換することができる．変換された文字列は，b64decode() によって
もとのバイト列に変換することができる．上述の encode()，decode() とは
向きが逆であることに注意されたい．encode() は文字列のメソッドで
バイト列に変換するものであったが，b64encode() は，バイト列を
文字列に変換するものである．

ただし，応用上の考慮から，b64encode() の返り値は文字列ではなく
バイト列になっている．これに decode() を適用することによって，
ASCII 文字列が得られる．b64decode() の方は，ASCII 文字列を指定する
ことができる．(ASCII文字列を encode() したバイト列を指定しても良い)


```python
from base64 import b64encode, b64decode

print(b64encode(b'\x00\x01\xff'))           # b'AAH/'
print(b64encode(b'\x00\x01\xff').decode())  # AAH/
print(b64decode('AAH/'))                    # b'\x00\x01\xff'
print(b64decode(b'AAH/'))                   # b'\x00\x01\xff'
```

## 暗号学的ハッシュ関数

scrypt ライブラリで実装されているメソッド hash() は，
バイト列からハッシュ値と呼ばれるバイト列を計算するものであり，
[暗号学的ハッシュ関数](https://ja.wikipedia.org/wiki/%E6%9A%97%E5%8F%B7%E5%AD%A6%E7%9A%84%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E9%96%A2%E6%95%B0) 
と呼ばれるものの1つである．
次のような性質がある．

1. ハッシュ値から，元のバイト列を得ることがきわめて困難 (大きな計算時間を要する) である．
2. 同一のハッシュ値を持つ2つのバイト列を求めることがきわめて困難である．
3. 元のバイト列をほんの少し変えただけで，ハッシュ値が大幅に変わる．

さしあたり，パスワードに関して重要なのは第1,3の性質である．

このハッシュ関数を利用して，次のようにパスワードを照合することが考えられる．

* ユーザがパスワードを決めたとき，そのハッシュ値を計算し，
  これをデータベースに格納する．
* ユーザを認証するときには，ユーザが提示したパスワードから，
  ハッシュ値を計算し，格納してあるハッシュ値と比較する．
  これらが一致したら，正しいユーザだと認める．
  
だいたいこの考え方でよいのだが，1つの問題点として，このままだと
辞書攻撃に弱いということがある．

ユーザのパスワードのハッシュ値一覧が攻撃者に盗まれたとしよう．
ユーザのうちの2人が，たまたま同じパスワードを使っていると，
ハッシュ値も一致しているから，その事実が攻撃者にわかってしまう．
こういう場合，典型的には `123456` などの弱いパスワードであることが
多いので，推測される危険が高まる．

また，
辞書に載っている単語をパスワードにしている利用者がいた場合，
攻撃者が辞書のすべての単語の
ハッシュ値を計算して，比較をする，といった方法で，
パスワードが判明してしまう可能性がある．

これらの危険を緩和するために，salt という，ランダムなバイト列が用いられる．
この salt をパスワードに追加したバイト列のハッシュ値を計算し，
salt とともに保管しておく．パスワード照合時には，送られてきた
パスワードに salt を追加してからハッシュ値を計算する．
このようにすると，複数人が同じパスワードを使っていても，
格納しているテーブルには，同じバイト列は現れない．また，辞書攻撃についても，
登録されている人数分の計算をしなければならなくなるため，危険が緩和される．

このsaltを用いる方法は標準的に推奨されているので，
scrypt の hash メソッドは，
`scrypt.hash(password, salt)` というように，
第2引数に salt を受け入れるようになっている．
どちらの引数も バイト列 を与えることになっているので，
password には，ユーザが入力した文字列を encode() してバイト列に
変換したものを指定する．salt には，`os.urandom(64)` などの，ランダムな
バイト列を指定する．
scrypt.hash() が計算するハッシュ値も，`os.urandom(64)` の値も
バイト列であるので，テーブルに格納する際には，文字列に変換しておいた方が
便利である．ここには，base64 エンコーディングを用いる．

以上の検討結果より，テーブルに格納する値は，次のように作成すれば
良いことが分かる (前節のコードの再掲):

```python
    import os
    from base64 import b64encode, b64decode

    bin_salt = os.urandom(64)                               # バイト列の salt
    bin_hashed = scrypt.hash(password.encode(), bin_salt)   # バイト列のハッシュ値
    salt = b64encode(bin_salt)                              # salt を文字列に
    hashed = b64encode(bin_hashed)                          # ハッシュ値を文字列に
```

また，照合の際には以下の手順を取れば良いことが分かる 
(前節のコードと本質的に同じ) 

```python
    password = ... # ユーザが入力したパスワード
    (hashed, salt) = ... # テーブルに格納されているハッシュ値とsalt
    bin_salt = b64decode(salt)                                  # バイト列のsaltを復元
    bin_hashed = b64decode(hashed)                              # バイト列のハッシュ値を復元
    if scrypt.hash(password.encode(), bin_salt) == bin_hashed:  # ハッシュ値の比較
        # 照合成功
    else:
        # 照合失敗
```

## 暗号学的疑似乱数

salt に用いるランダムな値として，
[os.urandom()](https://docs.python.org/ja/3/library/os.html#os.urandom)
が返す値を用いると
述べた．Python には，ランダムな値を発生させる方法として，
[random ライブラリ](https://docs.python.org/ja/3/library/random.html)
に種々のメソッドが用意されている．
しかし，これらのメソッドが
生成する値を salt に用いるのは適切ではない．

```python
import random, os

print(bytes([random.randrange(0,256) for i in range(64)]))
print(os.urandom(64))
```

どちらも同じようにランダムなバイト列が返されているように見える．
しかし，random ライブラリが実装しているのは
seed と呼ばれる
特定の値から順に計算によって作成される数の列である．
これは，シミュレーションのように，再現可能であって，しかも
ランダムに見える列が望まれる状況に適している．
しかし，salt の生成の場合には，
攻撃者が何らかの方法で seed を特定することができると，
すべての値を再現されてしまうという問題がある．

これに対して urandom は，オペレーティングシステムが提供する，
ユーザのキータイプ間の時間や，
ネットワークを流れるデータの揺れなどの物理的な方法等も用いながら
疑似乱数を発生させる，
暗号学的に安全な疑似乱数発生器 
(cryptographically-secure pseudorandom number generator = CSPRNG) 
を用いている．その値は予測不可能だと考えられる．








